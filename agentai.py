# -*- coding: utf-8 -*-
"""AgentAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11G3iURrjBLFDRxobyYmEF8sGskJgCK3c
"""

# ---------- Install required packages ----------
!pip install --quiet --upgrade langchain openai faiss-cpu requests google-auth-oauthlib google-api-python-client beautifulsoup4 serpapi tldextract
!pip install -U langchain-community

# ---------- Imports ----------
import os, re, json, time, requests
from typing import List, Dict
from bs4 import BeautifulSoup

# LangChain
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import FAISS
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.docstore.document import Document
from langchain.chat_models import ChatOpenAI
from langchain.chains import RetrievalQA
from langchain.tools import Tool
from langchain.agents import initialize_agent, AgentType

# Google APIs
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build

# ---------- CONFIG: safely enter keys ----------
os.environ["OPENAI_API_KEY"] = "YOUR_OPENAI_API_KEY" # Replace with your actual API key
os.environ["SERPAPI_KEY"] =  "search api key"

GOOGLE_CLIENT_SECRETS = "/content/my-project-01-418012-80bbcaae89e3.json"   # upload in Colab
GOOGLE_SCOPES = [
    "https://www.googleapis.com/auth/calendar.events",
    "https://www.googleapis.com/auth/calendar"
]



# ---------- Web search & scraping ----------
def serpapi_search(query: str, num: int = 6) -> List[dict]:
    api_key = os.environ.get("SERPAPI_KEY")
    url = "https://serpapi.com/search.json"
    params = {"q": query, "engine": "google", "num": num, "api_key": api_key}
    r = requests.get(url, params=params, timeout=15)
    return r.json().get("organic_results", [])

def fetch_text_from_url(url: str) -> str:
    try:
        r = requests.get(url, headers={"User-Agent": "Mozilla/5.0"}, timeout=10)
        soup = BeautifulSoup(r.text, "html.parser")
        for s in soup(["script", "style", "nav", "footer", "header"]):
            s.decompose()
        text = "\n".join([t.strip() for t in soup.get_text().splitlines() if t.strip()])
        return text[:50_000]
    except Exception:
        return ""

def extract_contacts(text: str) -> Dict[str, List[str]]:
    emails = re.findall(r"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}", text)
    phones = re.findall(r"(?:\+\d{1,3}[\s-]?)?\d{3,4}[\s-]?\d{3,4}[\s-]?\d{3,4}", text)
    return {"emails": list(set(emails)), "phones": list(set(phones))}

# ---------- RAG: company info ----------
def get_llm_and_embeddings():
    llm = ChatOpenAI(model="gpt-5-mini", temperature=0.0)
    embed = OpenAIEmbeddings(model="text-embedding-3-small")
    return llm, embed

def build_rag_for_company(company: str):
    results = serpapi_search(company + " company official site linkedin crunchbase news")
    docs = []
    for r in results:
        link = r.get("link") or r.get("url")
        if not link:
            continue
        text = fetch_text_from_url(link)
        if not text:
            continue
        splitter = RecursiveCharacterTextSplitter(chunk_size=1200, chunk_overlap=150)
        for i, chunk in enumerate(splitter.split_text(text)):
            docs.append(Document(page_content=chunk, metadata={"url": link, "chunk": i}))
    if not docs:
        raise ValueError("No documents fetched. Check SERPAPI key or company name.")
    _, embed = get_llm_and_embeddings()
    index = FAISS.from_documents(docs, embed)
    return index.as_retriever(), results

def answer_company_query(company: str):
    retriever, results = build_rag_for_company(company)
    llm, _ = get_llm_and_embeddings()
    qa = RetrievalQA.from_chain_type(llm=llm, chain_type="stuff", retriever=retriever)
    summary = qa.invoke({"query": f"Give a concise overview of {company}: core products, services, country, and 3 key facts."})["result"]
    text = "\n".join([d.page_content for d in retriever.get_relevant_documents(company)[:5]])
    contacts = extract_contacts(text)
    return {"summary": summary, "contacts": contacts, "sources": [r.get("link") for r in results[:3]]}

# ---------- Google Calendar / Meet ----------
def google_calendar_authenticate():
    if not os.path.exists(GOOGLE_CLIENT_SECRETS):
        raise FileNotFoundError("Upload your OAuth client_secrets.json to /content/")
    flow = InstalledAppFlow.from_client_secrets_file(GOOGLE_CLIENT_SECRETS, scopes=GOOGLE_SCOPES)
    creds = flow.run_local_server(port=0)
    return creds

def create_google_meet_event(creds: Credentials, summary: str, start_iso: str, end_iso: str,
                             description: str = "", attendees: List[str] = None, tz: str = "Asia/Kolkata"):
    service = build("calendar", "v3", credentials=creds, cache_discovery=False)
    event = {
        "summary": summary,
        "description": description,
        "start": {"dateTime": start_iso, "timeZone": tz},
        "end": {"dateTime": end_iso, "timeZone": tz},
        "conferenceData": {
            "createRequest": {
                "requestId": f"meet-{int(time.time())}",
                "conferenceSolutionKey": {"type": "hangoutsMeet"},
            }
        },
    }
    if attendees:
        event["attendees"] = [{"email": a} for a in attendees]
    created = service.events().insert(calendarId="primary", body=event, conferenceDataVersion=1).execute()
    meet_link = None
    for ep in created.get("conferenceData", {}).get("entryPoints", []):
        if ep.get("entryPointType") == "video":
            meet_link = ep.get("uri")
    return {"meet_link": meet_link, "event": created}

# ---------- Business Trip (optional lightweight planner) ----------
def plan_business_trip(origin, dest, depart, return_date=None, preference="economic"):
    transport = "train/bus or low-cost flight" if preference == "economic" else "flight (fastest)"
    cost = "₹2000–₹8000" if preference == "economic" else "₹3000–₹15000"
    time_est = "4–12h train, 1–3h flight" if preference == "economic" else "1–6h"
    return {
        "origin": origin,
        "destination": dest,
        "depart": depart,
        "return": return_date,
        "recommended_transport": transport,
        "estimated_cost": cost,
        "estimated_time": time_est,
    }

def schedule_trip_in_calendar(creds: Credentials, trip):
    service = build("calendar", "v3", credentials=creds, cache_discovery=False)
    evt = {
        "summary": f"Travel: {trip['origin']} → {trip['destination']}",
        "start": {"dateTime": trip['depart'] + "T08:00:00", "timeZone": "Asia/Kolkata"},
        "end": {"dateTime": trip['depart'] + "T10:00:00", "timeZone": "Asia/Kolkata"},
        "description": json.dumps(trip),
    }
    e = service.events().insert(calendarId="primary", body=evt).execute()
    return [e.get("htmlLink")]

# ---------- LangChain Tool Wrappers ----------
def tool_research_company(name: str) -> str:
    try:
        return json.dumps(answer_company_query(name))
    except Exception as e:
        return json.dumps({"error": str(e)})

def tool_create_meet(payload: str) -> str:
    try:
        data = json.loads(payload)
        creds = google_calendar_authenticate()
        attendees = data.get("attendees", [])
        if isinstance(attendees, str):
            attendees = [a.strip() for a in attendees.split(",") if a.strip()]
        evt = create_google_meet_event(
            creds,
            data.get("summary", "Meeting"),
            data["start_iso"],
            data["end_iso"],
            data.get("description", ""),
            attendees,
        )
        return json.dumps({"meet_link": evt["meet_link"], "eventId": evt["event"]["id"]})
    except Exception as e:
        return json.dumps({"error": str(e)})

def tool_plan_trip(payload: str) -> str:
    try:
        d = json.loads(payload)
        return json.dumps(plan_business_trip(d["origin"], d["dest"], d["depart"], d.get("return"), d.get("preference", "economic")))
    except Exception as e:
        return json.dumps({"error": str(e)})

def tool_schedule_trip(payload: str) -> str:
    try:
        trip = json.loads(payload)
        creds = google_calendar_authenticate()
        return json.dumps({"calendar_links": schedule_trip_in_calendar(creds, trip)})
    except Exception as e:
        return json.dumps({"error": str(e)})

research_tool = Tool("research_company", tool_research_company, "Get company info and contacts.")
meet_tool = Tool("create_google_meet", tool_create_meet, "Create Google Meet; JSON {summary,start_iso,end_iso,attendees}")
trip_tool = Tool("plan_business_trip", tool_plan_trip, "Plan trip; JSON {origin,dest,depart,return,preference}")
schedule_tool = Tool("schedule_trip", tool_schedule_trip, "Add trip to Calendar; JSON trip info")

# ---------- Initialize Agent (chat model + function calling) ----------
llm_agent = ChatOpenAI(model="gpt-5-mini", temperature=0.0)
tools = [research_tool, meet_tool, trip_tool, schedule_tool]

agent = initialize_agent(
    tools,
    llm_agent,
    agent=AgentType.OPENAI_FUNCTIONS,
    verbose=True
)

